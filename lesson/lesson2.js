// let test = 'eew';
// let test2 = 'eeerf';

// console.log(`${test}${test}`);

// const multiple = 5;

// function isEven (numb) {
// 	return numb+multiple
// }

// console.log(isEven(2));

// let message = 'dudfbfhj';
// message = 67383;

// let number = 5;
// number = 3.4;

// console.log(number);

// СПЕЦИАЛЬНЫЕ ЧИСЛОВЫЕ ЗНАЧЕНИЯ Infinity, -Infinity, NaN
// Infinity - математическая бесконечность. Особое значение, которое больше любого числа

// alert(1/0) // = infinity
// alert( infinity )

// alert('hdkj' / 2); // NaN = вычислительная ошибка. + любая математическая оперция с NaN возвращает NaN
// alert(NaN + 1); 
// alert(3 * 3);
// alert('fefi' / 3*4);
// Если где то в выражении получится NaN, то оно распространится на весь результат.
// ОДНО ИСКЛЮЧЕНИЕ: NaN ** 0 равно 1

// alert(856749875763849018091746487562389418n)

// let string = 'hfjhfhdsfew';
// let string2 = "jdfksfkffheh";
// let stringPhrase = `fhfh ffw fewieji ${123786}`
// console.log(string, string2, stringPhrase);

// alert(`sjkkjd ${23748 + 8783} hefkhdskj`)
// let name = 'pavel';
// alert(`Hi ${name}`);

// boolean может принимать только true(да, правильно) и false(Нет, не правильно)

// let qwerty = 4 < 1;
// alert(qwerty);

// NULL - Представляет собой ничего. Пусто. Значение не известно. И не является ссылкой на несуществующий объект

// let age = null;

// UNDEFINED - значение не было присвоено

// let age;
// alert(age);

// В OBJECT хранятся коллекции данных или более сложные структуры
// В SYMBOL исп. для создания уникальных id

// TYPEOF возвращает тип аргумента.
// 1. Синтаксис оператора: typeof x
// 2. Синтаксис функции: typeof (x).



//         NUMBER       для любых чисел: целочисленные значения ограничены диапазоном ±(253-1).
//         BIGINT       для целых чисел произвольной длины.
//         STRING       для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
//         BOOLEAN      для true/false.
//         NULL         для неизвестных значений – отдельный тип, имеющий одно значение null.
//         UNDEFINED    для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
//         OBJECT (особенный)     для более сложных структур данных.
//         SYMBOL       для уникальных идентификаторов.
//         TYPEOF       Имеет две формы: typeof x или typeof(x).
//                      Возвращает строку с именем типа. Например, "string".
//                      Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.



// let age = 4 + 5 + '4';

// alert(9 ** (1/6));

// let a, s, d;

// a = b = c = 2 + 3;
// alert(a); =5
// alert(b); =5
// alert(c); =5

// let n = 2;
// n += 4;
// n *= 2;
// alert(n);

// let counter = 2;
// n = counter++;
// alert(n);


// "" + 1 + 0 //string 10
// "" - 1 + 0 // number -1
// true + false // number 1
// 6 / "3" // number 2
// "2" * "3" // number 6
// 4 + 5 + "px" // string 9px
// "$" + 4 + 5 // string $45
// "4" - 2 // number 2
// "4px" - 2 // number 2              NaN
// " -9 " + 5 //string -95           -9 5
// " -9 " - 5 //number -14
// null + 1 // =1
// undefined + 1 // NaN
// "\t \n" - 2 // = -2


// let a = prompt("Первое число?", 1);
// let b = prompt("Второе число?", 2);

// alert(+a + +b); // 12

//											ШАБЛОННЫЕ СТРОКИ
/* Шаблонными литералами называют строковые литералы, которые могут исп. выражения внутри. Вместе с ними можно исп. многострочные литералы и строковую интерполяцию.*/

// 											СИНТАКСИС

// `строка текста`

// `строка текста 1
//  строка текста 2`

// `строка текста ${выражение} строка текста`

// tag `строка текста ${выражение} строка текста`: "теговый шаблон"
/*В этом случае, теговое выражение (обычно функция) вызывается с обработанным шаблонным литералом, который вы можете изменить перед выводом. Для экранирования обратной кавычки в шаблонных литералах указывается обратный слеш \.*/ 


// `\`` === '`' // --> true
// console.log()

// alert(2 > 6);
// alert(20 < 30);
// alert(20 != 20);

// 									СТРОГОЕ СРАВНЕНИЕ
// Исп. обыного сравнения == может вывзать проблемы. Оно не отличает 0 от False
// alert(0 == false); = истина
// Та же прблема с пустой строкой
// alert("" == false); = истина

/* Так происходит потому что операнды РАЗНЫХ ТИПОВ преобразуются оператором == к числу. */

// 										ОПЕРАТОР ===
// проверяет равенство без приведения типов.
// Если а и b разных типов, то оператор === немедленно возвращает false, без попытки преобразовния

// alert(0 === false); = false, поому что разные типы

// alert(null === undefined); = false, потому что при строгом равенстве, тут разные типы

// а вот:
// alert(null == undefined); = true, потому что при нестрогом равенстве, эти значения равны друг другу, НО БОЛЬШЕ НИЧЕМУ НЕ РАВНЫ. К примеру null ==0: false

// При сравнении значения null/undefined через операторы <> <= >=
// null Преобразуется к 0
// undefined преобразуестся к NaN

/*Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение (3) null >= 0 истинно, а null > 0 ложно.*/

// 									ЗАДАЧА

// 5 > 4   // true
// "ананас" > "яблоко" // false
// "2" > "12" /*false  (Правильно: true. В строковом типе, даже если там числа, проверка начинается с первого симвала. Соответственно проверяется 2 и 1. Поэтому тут true)*/
// undefined == null // true
// undefined === null // false
// null == "\n0\n" // false
// null === +"\n0\n" // false

// Правильно 6 из 7

// alert (undefined < 0); = false
// alert (undefined > 0); = false
// alert (undefined == 0); = false
// Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
// Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//										ЛОГИЧЕСКИЕ ОПЕРАТОРЫ
// if(0 || 0) {
// alert('Привет мир!');
// }

// alert(!!"whwndkj");
// alert(!!null);

// alert( null || 2 || undefined );
// alert( alert(1) || 2 || alert(3) );
// alert( 1 && null && 2 );
// alert( alert(1) && alert(2) );
// alert( null || 2 && 3 || 4 );

// let age = 90;
// if (age >= 14 && age <= 90) {
// 	alert('верно')
// }else{
// 	alert('неверно')
// }

// let age = 2;
// if (age >= 14 && age <= 90) {
// 	alert('false')
// }else{
// 	alert('true')
// }

// if (!(age >= 14 && age <= 90)){
// 	alert(true)


// if (-1 || 0) alert( 'first' );
// if (-1 && 0) alert( 'second' );
// if (null || -1 && 1) alert( 'third' );